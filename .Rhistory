#Switch value of end to return to top of loop 2
end <- 2
#Register untreated area.
untreated.area <- b.thresh$perc_cats[row.code] - b.actual$perc_cats[row.code]
meanUAA[t.code] <- sum(meanUAA[t.code], untreated.area)
#Modify "expected" area to show FDM this management option is complete
b.thresh$perc_cats[row.code] <- b.actual$perc_cats[row.code]
meanTAP[t.code] <- sum(b.actual$perc_cats[b.actual$t_code == t.code])
} else
{
#No, end disturbance loop.
#Switch value of end object to kill loop 2
end <- 3
#Register untreated area.
untreated.area <- b.thresh$perc_cats[row.code] - b.actual$perc_cats[row.code]
meanUAA[t.code] <- sum(meanUAA[t.code], untreated.area)
#Modify "expected" area to show FDM this management option is complete
b.thresh$perc_cats[row.code] <- b.actual$perc_cats[row.code]
meanTAP[t.code] <- sum(b.actual$perc_cats[b.actual$t_code == t.code])
}
}
if(end < 3)
{#2.2.1 ---------------------------------------------------------------------------
if(end < 2)
{#2.3.1 ---------------------------------------------------------------------------
#Records treatments selected for treatment so they will not be selected again
c.bun <- c(c.bun,bun)
t.bun <- b.unit$unit[!b.unit$unit %in% c.bun]
#Update tracking of area treated. Considers area of management unit selected, not actual
#area within the unit affected.
b.actual[row.code,10] <- sum(b.actual[row.code,10], sum(Area.List[MU.List == bun]))
meanTAA[t.code] <- sum(meanTAA[t.code], sum(Area.List[MU.List == bun]))
#Determine the treatment area. This is governed by the available fuelbeds, minimum stand
#area, and fraction of available area treated (beta distribution).
tbsa <- round(((length(b.map[b.map == bun & s.map %in% elst])) *
rbeta(1,shape1[t.code],shape2[t.code])),0)
#Initiate treatment in the proportion of available pixels specified in step 1 (cuts)
sct <- vector(mode = "numeric", length = 0)
sct <- resample(l.map[b.map == bun & s.map %in% elst],
round(max((tbsa * seed.cells[t.code]), 1),0))
if(tbsa >= 1)
{ #2.4.1 ---------------------------------------------------------------------------
#LOOP 3333333333333333333333333333333333333333333333333333333333333333333333
#Loop 3 (by treatment[b] by block). This loop keeps running until treatment
#has been mapped or stops establishing. Each time this loop runs it means that
#Loop 4 was not able to completely map the treatment. Each time this loop runs
#it will try and locate treatment[b] in a new location while maintaining the old
#one. Thus it is possible that a treatment will have multiple contigous areas. Each
#contigous area is referred to as a block and can have more than one stand if
#multiple fuelbeds are involved.
for (cc in 1:r.max)#cc <- 1
{ #3.0.0 ---------------------------------------------------------------------------
#Updated here in case any original stands have been completely overwritten
loopA.snO <- sort(unique(as.vector(s.map[!s.map %in% c(NoData.Unit,
loopB.new_stand,
loopC.new_stand)])))
#CAN YOU SWITCH THIS TO JUST c(NoData.Unit, loopB.new_stand, loopC.new_stand)
#WOULD REQUIRE CHANGING HOW THIS OBJECT IS USED THROUGHOUT FDM
#Pre-run Loop 4 number (used in tracking devices).
d <- 0
#Set up an intra loop tracking device for overwritten stand numbers.
#This will be fed into loopC.snNol
osnt <- vector(length = 0)
#Intraloop tracking mechanism for new stand coordinates (same as ocod in wildfire loop)
ocot <- vector(length = 0, mode = "numeric")
#Record area occupied by treatment[b].
#tbma <- max(length(sct), length(s.map[s.map %in% loopC.new_stand]))
tbma <- (length(sct) + ifelse(cc > 1, length(new.cells), 0))
#Ends loop when treatment[b] has been completely mapped.
if(tbma < tbsa)
{ #3.1.1 ---------------------------------------------------------------------------
#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>NEW
#Differentiate between initial loop and subsequent loops were you want to keep the
#treatment within the designated burn unit boundaries.
if(cc > 1)
{
#Initiate treatment in the proportion of available pixels specified in step 1 (cuts)
sct <- vector(mode = "numeric", length = 0)
} else
{
#No, initial block
sct <- sct
}
#Then find stands within this subset that meet minimum age requirements for
#the disturbance/treatment.
if(length(sct) > 0)
{ #3.2.1 ---------------------------------------------------------------------------
#Tracks the highest stand number currently in s.map.
#Used to assign new stand numbers for treatment[b].
#Can not place this below loop 4 in case treatment erases stand with highest number.
masn <- max(treat.stand,max(unique(as.vector(s.map[s.map < fire.stand]))))
#Establish treatment[b] in s.map and record old stand number
ocot <- c(ocot, sct) #tracks coordinates involved in disturbance.
s.map[sct] <- s.map[sct]*tesn_t
osnt <- c(osnt,s.map[sct])
tesn <- unique(osnt)
#LOOP 4444444444444444444444444444444444444444444444444444444444444444444444444444
#Loop 4 (by iterations). This loop keeps growing treatment[b] in block[cc]
#until growth stops.
for (d in 1:r.max)#d <- 1
{ #4.0.0 ---------------------------------------------------------------------------
#Area mapped for treatment[b].
tbma <- length(s.map[s.map %in% c(tesn,loopC.new_stand)])
#This statement stops loop 4 when treatment[b] has been fully mapped.
if(tbma < tbsa)
{ #4.1.1 ---------------------------------------------------------------------------
#Object shows locations of 8 pixels surrounding each mapped pixel for
#disturbance[e].
malo <- matrix(data = sn.seeker(search.set[1:8,1], search.set[1:8,2]),
length(s.map[s.map %in% tesn]),dcl_t, byrow = T)
#Object shows the upper and lower limits of pixel locations listed in the 'malo'
#object.
mali <- matrix(data = sn.limit(search.set[1:8,2], search.set[1:8,1]),
length(s.map[s.map %in% tesn]),dcl_t, byrow = T)
#Sets up information in malo and mali objects that replace location values with
#limits values if locations "spill" from map edges.
mixa <- c(malo[,1],malo[,2],mali[,3],mali[,4],mali[,5],mali[,6],mali[,7],malo[,8])
mixb <- c(mali[,1],mali[,2],malo[,3],malo[,4],malo[,5],malo[,6],malo[,7],mali[,8])
#Replaces location values with limit values where necessary (first draft - works
#on top and bottom of map)
fdlo <- ifelse(mixa < mixb,mali,malo)
#Replaces location values with limit values where necessary (second draft - works
#on sides of map)
sdlo <- ifelse(fdlo < 1,fdlo + rows,ifelse(fdlo > length(s.map),fdlo - rows,fdlo))
#This object shows all unique locations available for establishment by treatment[b].
avlo <- unique(l.map[sdlo][l.map[sdlo] %in% l.map[b.map == bun & s.map %in% elst]])
#Ends loop if there are no more locations available for treatment[b] in the
#block[cc] that is currently being mapped.
if(length(avlo) > 0)
{ #4.2.1 ---------------------------------------------------------------------------
#Reset new.cells object.
new.cells <- vector(length=0, mode = "numeric")
#This expression picks out which location values are of the same stand and are
#available (i.e. they are not occupied by the another treatment) and makes sure
#that the mapped regime does not exceed its prescribed area.
if((tbma + length(avlo)) <= tbsa)
{
new.cells <- avlo
s.map[new.cells] <- s.map[new.cells]*tesn_t
osnt <- c(osnt, s.map[new.cells])
tesn <- unique(osnt)
ocot <- c(ocot, new.cells) #tracks coordinates involved in disturbance.
} else
{
new.cells <- resample(avlo,(tbsa - tbma))
s.map[new.cells] <- s.map[new.cells]*tesn_t
osnt <- c(osnt, s.map[new.cells])
tesn <- unique(osnt)
ocot <- c(ocot, new.cells) #tracks coordinates involved in disturbance.
}
#Register mapping data after Loop 4 has finished running for iteration[d].
Iteration.cc[(length(Iteration.cc)+1)] <- cc
Explanation.cc[(length(Explanation.cc)+1)] <- "Block is running."
Iteration.d[(length(Iteration.d)+1)] <- d
Explanation.d[(length(Explanation.d)+1)] <- paste(c("Expansion. New pixels: ",
length(new.cells),"."), collapse = "")
Treatment.Area[(length(Treatment.Area)+1)] <- length(s.map[s.map %in% c(loopC.new_stand,
tesn)])
PrctTrmt.Mapped[(length(PrctTrmt.Mapped)+1)] <- round(((Treatment.Area[
length(Treatment.Area)]/tbsa)*100),1)
} else #4.2.1 ----------------------------------------------------------------------
{#4.2.2
Iteration.cc[(length(Iteration.cc)+1)] <- cc
Explanation.cc[(length(Explanation.cc)+1)] <- paste(
"Cannot expand block. Advance.", collapse = "")
Iteration.d[(length(Iteration.d)+1)] <- d
Explanation.d[(length(Explanation.d)+1)] <- paste(c("End expansion. Total: ",
length(s.map[s.map %in% tesn]),"."), collapse = "")
Treatment.Area[(length(Treatment.Area)+1)] <- length(s.map[s.map %in% c(loopC.new_stand,
tesn)])
PrctTrmt.Mapped[(length(PrctTrmt.Mapped)+1)] <- round(((Treatment.Area[
length(Treatment.Area)]/tbsa)*100),1)
#Save run data.
dt <- Sys.Date()
tm <- format(Sys.time(), format = "%H.%M.%S",
tz = "", usetz = FALSE)
cat(paste("run_", run,"_", dt,"_",tm,"_year_",a,"__", f.treatments$TreatmentName[t.code],
"_",b, "__block_",cc,"__expansion_" , "_",d,"__.txt",sep = ""),
file = paste("run_", run, "_iterations.txt", sep = ""), fill = T, append = T)#
break
} #4.2.2 ---------------------------------------------------------------------------
} else #4.1.1 ----------------------------------------------------------------------
{ #4.1.2 ---------------------------------------------------------------------------
Iteration.cc[(length(Iteration.cc)+1)] <- cc
Explanation.cc[(length(Explanation.cc)+1)] <- paste(
"Treatment mapped. New block.", collapse = "")
Iteration.d[(length(Iteration.d)+1)] <- d
Explanation.d[(length(Explanation.d)+1)] <- paste(c("End expansion. Total: ",
length(s.map[s.map %in% tesn]),"."), collapse = "")
Treatment.Area[(length(Treatment.Area)+1)] <- length(s.map[s.map %in% c(loopC.new_stand,
tesn)])
PrctTrmt.Mapped[(length(PrctTrmt.Mapped)+1)] <- round(((Treatment.Area[
length(Treatment.Area)]/tbsa)*100),1)
#Save run data.
dt <- Sys.Date()
tm <- format(Sys.time(), format = "%H.%M.%S",
tz = "", usetz = FALSE)
cat(paste("run_", run,"_", dt,"_",tm,"_year_",a,"__", f.treatments$TreatmentName[t.code],
"_",b, "__block_",cc,"__expansion_" , "_",d,"__.txt",sep = ""),
file = paste("fdm_iterations_status/run_", run, "_iterations.txt", sep = ""), fill = T, append = T)#
break
} #4.1.2 ---------------------------------------------------------------------------
#Save run data.
dt <- Sys.Date()
tm <- format(Sys.time(), format = "%H.%M.%S",
tz = "", usetz = FALSE)
cat(paste("run_", run,"_", dt,"_",tm,"_year_",a,"__", f.treatments$TreatmentName[t.code],
"_",b, "__block_",cc,"__expansion_" , "_",d,"__.txt",sep = ""),
file = paste("fdm_iterations_status/run_", run, "_iterations.txt", sep = ""), fill = T, append = T)#
} #4.0.0 ---------------------------------------------------------------------------
#Find unique fuelbeds in each management unit
#Unique old stands
osto <- sort(unique(tesn))
#Log old stand numbers and area before they are changed in s.map.
loopC.old_stand <- c(loopC.old_stand,osto)
#Number of stands
nobc <- length(osto)
#Determine new stand numbers for treatment[b], block[cc].
nebc <- seq((masn + 1), (masn + nobc), 1)
#Map new stands
tn <- data.frame(osnt = osnt, ocot = ocot)
tn.b <- tn[order(tn$ocot),]
v.nebc <- nebc[match(tn.b$osnt, osto)]
s.map[l.map %in% tn.b$ocot] <- v.nebc
#Log new stand numbers and associated treatments when they have been added to s.map.
loopC.new_stand <- c(loopC.new_stand,nebc)
loopC.treat_type <- c(loopC.treat_type,rep(t.code,nobc))
loopC.new_mgmtUnit <- c(loopC.new_mgmtUnit,rep(bun, length(nebc)))
#loopC.new_area <- c(loopC.new_area,mapply(function(x) length(s.map[s.map == x]),nebc))
l.nebc <- rep(1,length(v.nebc))
s.nebc <- summarize(l.nebc,v.nebc,sum)
loopC.new_area <- c(loopC.new_area, as.vector(s.nebc[,2]))
} else #3.2.1 ----------------------------------------------------------------------
{ #3.2.2 ---------------------------------------------------------------------------
Iteration.cc[(length(Iteration.cc)+1)] <- cc
Explanation.cc[(length(Explanation.cc)+1)] <- paste(
"Error - Treatment was not started (cc = 1), or not finished (cc = 2).", collapse = "")
Iteration.d[(length(Iteration.d)+1)] <- 0
Explanation.d[(length(Explanation.d)+1)] <- "Expansion not started."
Treatment.Area[(length(Treatment.Area)+1)] <- length(s.map[s.map %in% c(loopC.new_stand,
tesn)])
PrctTrmt.Mapped[(length(PrctTrmt.Mapped)+1)] <- round(((Treatment.Area[
length(Treatment.Area)]/tbsa)*100),1)
break
} #3.2.2 ---------------------------------------------------------------------------
} else #3.1.1 ----------------------------------------------------------------------
{ #3.1.2 ---------------------------------------------------------------------------
Iteration.cc[(length(Iteration.cc)+1)] <- cc
Explanation.cc[(length(Explanation.cc)+1)] <- paste(
"Treatment mapped. End Mapping.", collapse = "")
Iteration.d[(length(Iteration.d)+1)] <- d
Explanation.d[(length(Explanation.d)+1)] <- "Expansion not started."
Treatment.Area[(length(Treatment.Area)+1)] <- length(s.map[s.map %in% c(loopC.new_stand,
tesn)])
PrctTrmt.Mapped[(length(PrctTrmt.Mapped)+1)] <- round(((Treatment.Area[
length(Treatment.Area)]/tbsa)*100),1)
break
} #3.1.2 ---------------------------------------------------------------------------
d.d <- sum(d.d, d)#tracks expansions
} #3.0.0 ---------------------------------------------------------------------------
#Log treatment run data for treatment[b].
if(length(Iteration.cc) > 1)
Treatment.History[[(length(Treatment.History)+1)]] <- data.frame(
"Blocks" = Iteration.cc, "Block History" = Explanation.cc,
"Expansions" = Iteration.d, "Expansion History" = Explanation.d,
"Treatment Area" = Treatment.Area, "Percent Mapped" = PrctTrmt.Mapped,
stringsAsFactors = F) else
Treatment.History[[(length(Treatment.History)+1)]] <- paste(
"If this message shows up something weird happened. Error 3.0", collapse = "")
#Add header to list.
names(Treatment.History)[[length(Treatment.History)]] <- paste(c(
"Treatment Number: ",b," ### Treatment Type: ",
f.treatments$TreatmentTitle[t.code]," ### Treatment Area: ",
tbsa, " ### Area Mapped: ", Treatment.Area[length(Treatment.Area)],
" ### Completed: ",PrctTrmt.Mapped[length(PrctTrmt.Mapped)], "% ###"),
collapse = "")
#Log new stand numbers and associated treatments when they have been added to s.map.
loopB.new_stand <- c(loopB.new_stand,loopC.new_stand)
loopB.treat_type <- c(loopB.treat_type, loopC.treat_type)
loopB.new_mgmtUnit <- c(loopB.new_mgmtUnit,loopC.new_mgmtUnit)
loopB.new_area <- c(loopB.new_area,loopC.new_area)
loopB.old_stand <- c(loopB.old_stand,loopC.old_stand)
loopB <- data.frame(new_stand = loopB.new_stand,
treat_type = loopB.treat_type,
new_mgmtUnit = loopB.new_mgmtUnit,
new_area = loopB.new_area,
old_stand = loopB.old_stand * -1)
loopB <- loopB[order(loopB$old_stand),]
#Date and time
dt <- Sys.Date()
tm <- format(Sys.time(), format = "%H.%M.%S",
tz = "", usetz = FALSE)
#Tracking device
t.summary <- paste(
"Date: ", dt,
" Time: ", tm,
" Year: ", a,
" PercentComplete_ForYear: ", round((((sum(meanTAA)-sum(meanUAA))/sum(meanTAP))*100),2),
" Disturbance_No ", b,
" Name: ", f.treatments$TreatmentTitle[t.code],
"MgmtOp: ", b.thresh$management_type[row.code],
"BurnBlock: ", bun,
"PercentBlack: ", round(tbsa/sum(Area.List[MU.List == bun]), 1),
" TreatedArea_Expected: ", tbsa,
" TreatedArea_Actual: ", tbma,
"Untreated_Area: ", untreated.area,
" Blocks: ", cc,
" Expansions: ", d.d,
"HiStandNo: ", max(nebc))
#e.summary <- rbind(e.summary, t.summary)
#Save run data.
cat(t.summary, file = paste("fdm_disturbances_status/run_", run, "_disturbances.txt",
sep = ""), fill = T, append = T)#
} else #2.4.1 ----------------------------------------------------------------------
{ #2.4.2 ---------------------------------------------------------------------------
#Log treatment run data for treatment[b].
if(length(Iteration.cc) > 1)
Treatment.History[[(length(Treatment.History)+1)]] <- paste(
"If this message shows up something weird happened. Error 2.1.",
collapse = "") else
Treatment.History[[(length(Treatment.History)+1)]] <- paste(
"No space available to map treatment. Mapping was not attempted.", collapse = "")
#Add header to list.
names(Treatment.History)[[length(Treatment.History)]] <- paste(c(
"Treatment Number: ",b," ### Treatment Type: ",
f.treatments$TreatmentTitle[t.code]," ### Treatment Area: ",
tbsa, " ### Area Mapped: ", Treatment.Area[length(Treatment.Area)],
" ### Completed: ", PrctTrmt.Mapped[length(PrctTrmt.Mapped)], "% ###"),
collapse = "")
#Log new stand numbers and associated treatments when they have been added to s.map.
loopB.new_stand <- c(loopB.new_stand,loopC.new_stand)
loopB.treat_type <- c(loopB.treat_type, loopC.treat_type)
loopB.new_mgmtUnit <- c(loopB.new_mgmtUnit,loopC.new_mgmtUnit)
loopB.new_area <- c(loopB.new_area,loopC.new_area)
loopB.old_stand <- c(loopB.old_stand,loopC.old_stand)
loopB <- data.frame(new_stand = loopB.new_stand,
treat_type = loopB.treat_type,
new_mgmtUnit = loopB.new_mgmtUnit,
new_area = loopB.new_area,
old_stand = loopB.old_stand * -1)
loopB <- loopB[order(loopB$old_stand),]
#Date and time
dt <- Sys.Date()
tm <- format(Sys.time(), format = "%H.%M.%S",
tz = "", usetz = FALSE)
#Tracking device
t.summary <- paste(
"Date: ", dt,
" Time: ", tm,
" Year: ", a,
" PercentComplete_ForYear: ", round((((sum(meanTAA)-sum(meanUAA))/sum(meanTAP))*100),2),
" Disturbance_No ", b,
" Name: ", f.treatments$TreatmentTitle[t.code],
"MgmtOp: ", b.thresh$management_type[row.code],
"BurnBlock: ", bun,
"PercentBlack: ", round(tbsa/sum(Area.List[MU.List == bun]), 1),
" TreatedArea_Expected: ", tbsa,
" TreatedArea_Actual: ", tbma,
"Untreated_Area: ", untreated.area,
" Blocks: ", cc,
" Expansions: ", d.d,
"HiStandNo: ", max(nebc))
#e.summary <- rbind(e.summary, t.summary)
#Save run data.
cat(t.summary, file = paste("fdm_disturbances_status/run_", run, "_disturbances.txt",
sep = ""), fill = T, append = T)#
} #2.4.2 ---------------------------------------------------------------------------
} else #2.3.1 ----------------------------------------------------------------------
{ #2.3.2 ---------------------------------------------------------------------------
#Date and time
dt <- Sys.Date()
tm <- format(Sys.time(), format = "%H.%M.%S",
tz = "", usetz = FALSE)
#Tracking device
t.summary <- paste(
"Date: ", dt,
" Time: ", tm,
" Year: ", a,
" PercentComplete_ForYear: ", round((((sum(meanTAA)-sum(meanUAA))/sum(meanTAP))*100),2),
" Disturbance_No ", b,
" Name: ", f.treatments$TreatmentTitle[t.code],
"MgmtOp: ", b.thresh$management_type[row.code],
"BurnBlock: ", bun,
"PercentBlack: ", round(tbsa/sum(Area.List[MU.List == bun]), 1),
" TreatedArea_Expected: ", tbsa,
" TreatedArea_Actual: ", tbma,
"Untreated_Area: ", untreated.area,
" Blocks: ", cc,
" Expansions: ", d.d,
plot(c(1,2))
USE_GPU <- FALSE
s.map <- matrix(rep(10,100), 10,10)
l.map <- matrix(seq(1,100,1), 10,10)
find_actively_burning_cells()
find_actively_burning_cells_in_smap <- function()
{
v1 <- s.map
v2 <- tesn
return (which(v1 %in% v2))
}
find_neighbors <- function(x, radius, row_cnt = rows, col_cnt = cols)
{
# Unit tests: shift(seq(1,20), 0, 0, row_cnt=5) = seq(1,20)
#             shift(seq(1,20), -1, 0, row_cnt=5) = c(1,2,3,4,5,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
#             shift(seq(1,20), 0, 1, row_cnt=5) = c(2,3,4,5,5,7,8,9,10,10,12,13,14,15,15,17,18,19,20,20)
#             shift(seq(1,20), -3, 2, row_cnt=5) = c(1,2,3,11,12,6,7,8,16,17,11,12,13,14,15,16,17,18,19,20)
params <- expand.grid(x, seq(-radius,radius,1), seq(-radius,radius,1))
params <- params[!(params[,2]==0 & params[,3]==0),]
x_row = ifelse(params[,1] %% row_cnt == 0, row_cnt, params[,1] %% row_cnt)  # row number
x_col = ifelse(params[,1] %% row_cnt == 0, params[,1] %/% row_cnt, params[,1] %/% row_cnt + 1)  # column number
if (USE_GPU) {
params <- g(params)
x_row <- g(x_row)
x_col <- g(x_col)
row_cnt <- g(row_cnt)
col_cnt <- g(col_cnt)
}
result <- ifelse(x_row + params[,2] > 0 & x_row + params[,2] <= row_cnt & x_col + params[,3] > 0 & x_col + params[,3] <= col_cnt,
params[,1] + params[,3]*row_cnt + params[,2], 0)
if (USE_GPU) {
params <- h(params)
x_row <- h(x_row)
x_col <- h(x_col)
row_cnt <- h(row_cnt)
col_cnt <- h(col_cnt)
}
return (result)
}
find_actively_burning_cells()
find_actively_burning_cells_in_smap()
tesn <- 1
s.map[6,6] <- 1
find_actively_burning_cells_in_smap()
find_neighbors(find_actively_burning_cells_in_smap(), radius = 1)
rows <- 10
cols <- 10
find_neighbors(find_actively_burning_cells_in_smap(), radius = 1)
find_neighbors(find_actively_burning_cells_in_smap(), radius = 2)
l.map
#install.packages("gtools", repos="http://cran.fhcrc.org/")
library(Hmisc) #for summarize()
library(GenKern)#for nearest()
library(SDMTools)
library(gtools)  #for combinations()ge
library(utils)#for Rprof()
try(host_sim_params <- read.csv("host_sim_params.txt"), silent=TRUE)
host_sim_params <- read.csv("host_sim_params.txt")
host_sim_params
exists("host_sim_params") && "run_id" %in% colnames(host_sim_params)
install.packages("gmatrix")
install.packages("gmatrix")
install.packages("gmatrix")
install.packages("Hmisc")
library(Hmisc)
install.packages("Hmisc")
install.packages("gmatrix")
library(gmatrix)
install.packages("gmatrix")
??gmatrix
?gmatrix
library(Hmisc) #for summarize()
library(GenKern)#for nearest()
library(SDMTools)
library(gtools)  #for combinations()ge
library(utils)#for Rprof()
library(Hmisc) #for summarize()
library(GenKern)#for nearest()
library(SDMTools)
library(gtools)  #for combinations()ge
library(utils)#for Rprof()
library(Hmisc) #for summarize()
library(GenKern)#for nearest()
library(SDMTools)
library(gtools)  #for combinations()ge
library(utils)#for Rprof()
library(Hmisc)
library(GenKern)
120000 + (10 *100000)
(120000 * 100) + 88
(129567 * 100) + 88
(60857 * 100) + 88
(60857 * 100) + 1
(1 * 100) + 1
setwd("C:/Users/jcronan/Documents/GitHub/FDM/")
input_file_1 <- read.table("input_file.csv", header=TRUE,
sep=",", na.strings="NA", dec=".", strip.white=TRUE)
input_file_2 <- read.table("input_file_2.csv", header=TRUE,
sep=",", na.strings="NA", dec=".", strip.white=TRUE)
aa <- vector()
system.time({
for(i in 1:100000)
{
aa[i] <- 1 + min(0,aa[i-1])
}
})
dt <- Sys.Date()
tm <- format(Sys.time(), format = "%H.%M.%S",
tz = "", usetz = FALSE)
write.csv(aa, file = paste("output_file_on_",dt,"_",tm,".csv",sep = ""),
quote = TRUE, eol = "\n", na = "NA", row.names = FALSE)
aa <- vector()
system.time({
for(i in 1:100000)
{
aa[i] <- 1 + min(0,aa[i-1])
}
})
dt <- Sys.Date()
tm <- format(Sys.time(), format = "%H.%M.%S",
tz = "", usetz = FALSE)
write.csv(aa, file = paste("output_file_on_",dt,"_",tm,".csv",sep = ""),
quote = TRUE, eol = "\n", na = "NA", row.names = FALSE)
